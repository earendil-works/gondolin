import fs from "fs";
import path from "path";
import { execFileSync } from "child_process";

import { parseEnvEntry } from "../env-utils";
import { assertSafeWritePath } from "./rootfs";

/** Download helper using Node's built-in fetch */
export async function downloadFile(url: string, dest: string): Promise<void> {
  const res = await fetch(url, { redirect: "follow" });

  if (!res.ok) {
    throw new Error(`Failed to download ${url}: HTTP ${res.status}`);
  }

  const buf = Buffer.from(await res.arrayBuffer());
  fs.writeFileSync(dest, buf);
}

export function copyExecutable(
  src: string,
  dest: string,
  rootDir?: string,
): void {
  if (rootDir) {
    assertSafeWritePath(dest, rootDir);
  }
  fs.mkdirSync(path.dirname(dest), { recursive: true });
  fs.copyFileSync(src, dest);
  fs.chmodSync(dest, 0o755);
}

export function writeExecutable(
  dest: string,
  content: string,
  rootDir?: string,
): void {
  if (rootDir) {
    assertSafeWritePath(dest, rootDir);
  }
  fs.mkdirSync(path.dirname(dest), { recursive: true });
  fs.writeFileSync(dest, content, { mode: 0o755 });
}

export function injectBeforeSandboxdExec(
  script: string,
  snippet: string,
): string {
  const marker = "\nexec /usr/bin/sandboxd\n";
  const idx = script.lastIndexOf(marker);
  if (idx !== -1) {
    return (
      script.slice(0, idx) + "\n" + snippet.trimEnd() + "\n" + script.slice(idx)
    );
  }

  return script.trimEnd() + "\n" + snippet.trimEnd() + "\n";
}

export function generateImageEnvScript(
  env: Record<string, string> | string[],
): string | null {
  const entries = normalizeEnvEntries(env);
  if (entries.length === 0) return null;

  const lines = entries.map(
    ([key, value]) => `export ${key}=${shSingleQuote(value)}`,
  );

  return (
    "# Generated by gondolin build\n" +
    "# shellcheck shell=sh\n" +
    lines.join("\n") +
    "\n"
  );
}

function normalizeEnvEntries(
  env: Record<string, string> | string[],
): Array<[string, string]> {
  const map = new Map<string, string>();

  if (Array.isArray(env)) {
    for (const entry of env) {
      const [key, value] = parseEnvEntry(entry);
      validateEnvKey(key);
      map.set(key, value);
    }
  } else {
    for (const [key, value] of Object.entries(env)) {
      validateEnvKey(key);
      map.set(key, value);
    }
  }

  return Array.from(map.entries()).sort(([a], [b]) => a.localeCompare(b));
}

function validateEnvKey(key: string): void {
  if (!/^[A-Za-z_][A-Za-z0-9_]*$/.test(key)) {
    throw new Error(
      `Invalid env var name for image env: ${JSON.stringify(key)}`,
    );
  }
}

function shSingleQuote(value: string): string {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}

/** Find mke2fs / mkfs.ext4 binary */
export function findMke2fs(): string {
  for (const cmd of ["mke2fs", "mkfs.ext4"]) {
    try {
      execFileSync("which", [cmd], { stdio: "pipe" });
      return cmd;
    } catch {
      // continue
    }
  }

  if (process.platform === "darwin") {
    const candidates = [
      "/opt/homebrew/opt/e2fsprogs/sbin/mke2fs",
      "/opt/homebrew/opt/e2fsprogs/bin/mke2fs",
      "/opt/homebrew/opt/e2fsprogs/sbin/mkfs.ext4",
      "/opt/homebrew/opt/e2fsprogs/bin/mkfs.ext4",
      "/usr/local/opt/e2fsprogs/sbin/mke2fs",
      "/usr/local/opt/e2fsprogs/bin/mke2fs",
      "/usr/local/opt/e2fsprogs/sbin/mkfs.ext4",
      "/usr/local/opt/e2fsprogs/bin/mkfs.ext4",
    ];
    for (const candidate of candidates) {
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    }
  }

  throw new Error(
    "Missing required command: mke2fs (install e2fsprogs)\n" +
      "On macOS: brew install e2fsprogs\n" +
      "Then ensure mke2fs is on your PATH (Homebrew: brew --prefix e2fsprogs)",
  );
}

/** Create an ext4 rootfs image from a directory tree */
export function createRootfsImage(
  mkfsCmd: string,
  imagePath: string,
  sourceDir: string,
  label: string,
  fixedSizeMb?: number,
): void {
  let sizeMb: number;

  if (fixedSizeMb !== undefined) {
    sizeMb = fixedSizeMb;
  } else {
    const sizeKb = getDirSizeKb(sourceDir);
    const paddedKb = sizeKb + Math.floor(sizeKb / 5) + 65536;
    sizeMb = Math.ceil(paddedKb / 1024);
  }

  execFileSync(
    mkfsCmd,
    [
      "-t",
      "ext4",
      "-d",
      sourceDir,
      "-L",
      label,
      "-m",
      "0",
      "-O",
      "^has_journal",
      "-E",
      "lazy_itable_init=0,lazy_journal_init=0",
      "-b",
      "4096",
      "-F",
      imagePath,
      `${sizeMb}M`,
    ],
    { stdio: "pipe" },
  );
}

/** Create a compressed initramfs from a directory tree */
export function createInitramfs(sourceDir: string, outputPath: string): void {
  execFileSync(
    "sh",
    [
      "-c",
      `cd "${sourceDir}" && find . -print0 | cpio --null -ov --format=newc | lz4 -l -c > "${outputPath}"`,
    ],
    { stdio: "pipe" },
  );
}

function getDirSizeKb(dir: string): number {
  try {
    const output = execFileSync("du", ["-sk", dir], {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "pipe"],
    });
    return parseInt(output.split(/\s/)[0], 10) || 0;
  } catch {
    return Math.ceil(walkDirSize(dir) / 1024);
  }
}

function walkDirSize(dir: string): number {
  let size = 0;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isSymbolicLink()) {
      continue;
    }
    if (entry.isDirectory()) {
      size += walkDirSize(full);
      continue;
    }
    if (entry.isFile()) {
      size += fs.statSync(full).size;
    }
  }
  return size;
}
