#!/usr/bin/env node
import { createHash } from "node:crypto";
import fs from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const REPO = "hochej/hogwash";
const ASSET_NAME = "secret-mapping.gondolin.json";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const packageRoot = path.resolve(__dirname, "..");
const outputPath = path.join(
  packageRoot,
  "src",
  "generated",
  "secret-mapping.ts",
);

function usage() {
  console.log(
    [
      "Usage:",
      "  node scripts/update-mapping.mjs --latest",
      "  node scripts/update-mapping.mjs --tag vX.Y.Z",
      "  node scripts/update-mapping.mjs --from-file path/to/secret-mapping.gondolin.json",
      "  node scripts/update-mapping.mjs --latest --sha256 <expected>",
    ].join("\n"),
  );
}

function parseArgs(argv) {
  let latest = false;
  let tag;
  let fromFile;
  let sha256;

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    switch (arg) {
      case "--latest":
        latest = true;
        break;
      case "--tag":
        tag = argv[++i];
        break;
      case "--from-file":
        fromFile = argv[++i];
        break;
      case "--sha256":
        sha256 = argv[++i];
        break;
      case "--help":
      case "-h":
        usage();
        process.exit(0);
      default:
        throw new Error(`Unknown argument: ${arg}`);
    }
  }

  const selected = [latest, Boolean(tag), Boolean(fromFile)].filter(
    Boolean,
  ).length;
  if (selected !== 1) {
    throw new Error(
      "Select exactly one source: --latest, --tag, or --from-file",
    );
  }

  if (sha256) {
    sha256 = sha256.toLowerCase();
  }

  return { latest, tag, fromFile, sha256 };
}

function githubHeaders(accept = "application/vnd.github+json") {
  const headers = {
    Accept: accept,
    "X-GitHub-Api-Version": "2022-11-28",
    "User-Agent": "earendil-secret-filter-mapping-generator",
  };

  const token = process.env.GITHUB_TOKEN;
  if (token) {
    headers.Authorization = `Bearer ${token}`;
  }

  return headers;
}

async function requestJson(url) {
  const response = await fetch(url, {
    headers: githubHeaders(),
  });

  if (!response.ok) {
    const body = await response.text();
    throw new Error(
      `GitHub API request failed (${response.status}) for ${url}: ${body}`,
    );
  }

  return response.json();
}

async function resolveLatestTag() {
  const data = await requestJson(
    `https://api.github.com/repos/${REPO}/releases/latest`,
  );
  if (
    !data ||
    typeof data.tag_name !== "string" ||
    data.tag_name.length === 0
  ) {
    throw new Error("GitHub API response missing release tag_name");
  }
  return data.tag_name;
}

async function resolveAssetDownloadUrl(tag) {
  const release = await requestJson(
    `https://api.github.com/repos/${REPO}/releases/tags/${encodeURIComponent(tag)}`,
  );

  if (!Array.isArray(release.assets)) {
    throw new Error(`Release ${tag} has no assets array`);
  }

  const asset = release.assets.find((item) => item?.name === ASSET_NAME);
  if (!asset || typeof asset.browser_download_url !== "string") {
    throw new Error(`Release ${tag} does not contain asset ${ASSET_NAME}`);
  }

  return asset.browser_download_url;
}

async function downloadText(url) {
  const response = await fetch(url, {
    headers: githubHeaders("application/octet-stream"),
  });

  if (!response.ok) {
    const body = await response.text();
    throw new Error(
      `Asset download failed (${response.status}) for ${url}: ${body}`,
    );
  }

  return response.text();
}

function sha256Hex(input) {
  return createHash("sha256").update(input).digest("hex");
}

function renderModule(rawJson, digest) {
  return `// AUTO-GENERATED FILE. DO NOT EDIT.\n//\n// Generated by: packages/secret-filter/scripts/update-mapping.mjs\n\nimport type { SecretMappingData } from "../types.ts";\n\nexport const SECRET_MAPPING_SHA256 = ${JSON.stringify(digest)};\n\nexport const SECRET_MAPPING_JSON = ${JSON.stringify(rawJson)};\n\nexport const SECRET_MAPPING_DATA: SecretMappingData = JSON.parse(\n  SECRET_MAPPING_JSON,\n) as SecretMappingData;\n`;
}

async function main() {
  const options = parseArgs(process.argv.slice(2));

  let rawJson;
  let sourceLabel;

  if (options.fromFile) {
    const resolved = path.resolve(options.fromFile);
    rawJson = await fs.readFile(resolved, "utf8");
    sourceLabel = resolved;
  } else {
    const tag = options.tag ?? (await resolveLatestTag());
    const url = await resolveAssetDownloadUrl(tag);
    rawJson = await downloadText(url);
    sourceLabel = `hogwash release ${tag}`;
  }

  JSON.parse(rawJson);

  const digest = sha256Hex(rawJson);
  if (options.sha256 && options.sha256 !== digest) {
    throw new Error(
      `Downloaded artifact checksum mismatch: expected ${options.sha256}, got ${digest}`,
    );
  }

  const content = renderModule(rawJson, digest);

  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, content, "utf8");

  console.log(`wrote ${path.relative(packageRoot, outputPath)}`);
  console.log(`source: ${sourceLabel}`);
  console.log(`sha256: ${digest}`);
}

main().catch((err) => {
  console.error(err instanceof Error ? err.message : String(err));
  process.exit(1);
});
